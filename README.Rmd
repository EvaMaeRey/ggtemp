---
output: 
  github_document:
    toc: TRUE

---


```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  eval = T
)
```


Proposing the {ggtemp} package! ðŸ¦„ 
<!-- (typical package introduction write up; but actually aspirational) -->

The goal of {ggtemp} is to make writing some quick useful extension functions succinct. Right now, the amount of code required to write extensions is a bit of a mouthful, and could feel prohibitive for day-to-day analysis.  Specifically, defining new geom_* and stat_* layers outside of the context of a package, I believe, is not common, but could be quite useful, ultimately making plot builds intiuitive, fun, and readable. However the usual amount of code required to make define new geom_* or stat_* functions, might feel like it 'gunks up' your script.

With the {ggtemp} package, we'll live in a different world (ðŸ¦„ ðŸ¦„ ðŸ¦„) where the task is a snap ðŸ«°, and the readability of the in-script definition of a geom_* or stat_* function is quite succinct: 

Proposed API where we create a new geom_* layer function

```
library(ggtemp)

# 1. work out some compute
compute_group_xmean <- function(data, scales){
  
  data |> # a dataframe with vars x, the required aesthetic
    summarize(x = mean(x)) |>
    mutate(xend = x) |>
    mutate(y = -Inf, yend = Inf)

}

# 2. create layer function based on compute geom_xmean)
create_layer_temp(fun_name = "geom_xmean",
                  compute_group = compute_group_xmean,
                  required_aes = "x",
                  geom = "segment")
                  
                  
# 3. Use temp layer!                   
ggplot(data = cars) + 
  aes(x = speed, y = dist) + 
  geom_point() + 
  geom_xmean()
```



# Part I. Work out functionality  âœ… 


## Intro Thoughts

What if you just want to define a basic computational engine (geom_* or stat_* function) on the fly in a script.  It seems like it requires a good amount of code, but there are things that repeat.  Below, we see if we define a StatTemp within a function, and use that function to remove some of the repetition for vanilla-y extensions.

TLDR:  This seems to work, and surprisingly well (??).  I thought I'd only be able to use StatTemp once, but you seem to be able to define multiple geoms_* functions with the same define_temp_geom wrapper...

## Status Quo:  1. compute, 2. ggproto, 3. define layer

```{r cars}
library(tidyverse)
compute_panel_equilateral <- function(data, scales, n = 15){
  
  data |> 
    mutate(group = row_number()) |> 
    crossing(tibble(z = 0:n)) |>
    mutate(around = 2*pi*z/max(z)) |> 
    mutate(x = x0 + cos(around)*r,
           y = y0 + sin(around)*r) 
  
}

StatCircle <- ggproto(
  `_class` = "StatCircle",
  `_inherit` = ggplot2::Stat,
  compute_panel = compute_panel_equilateral,
  required_aes = c("x0", "y0", "r"))

geom_circle <- function(
  mapping = NULL,
  data = NULL,
  position = "identity",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE, ...) {
  ggplot2::layer(
    stat = StatCircle,  # proto object from Step 2
    geom = ggplot2::GeomPolygon,  # inherit other behavior
    data = data,
    mapping = mapping,
    position = position,
    show.legend = show.legend,
    inherit.aes = inherit.aes,
    params = list(na.rm = na.rm, ...)
  )
}

data.frame(x0 = 0:1, y0 = 0:1, r = 1:2/3) |> 
  ggplot() + 
  aes(x0 = x0, y0 = y0, r = r) + 
  geom_circle() + 
  aes(fill = r)
```

## Experimental:  `define_layer_temp()` combines 2 and 3 in using a temp stat


```{r define_layer_temp}
define_layer_temp <- function(
  required_aes,
  compute_panel = NULL, 
  compute_group = NULL,
  geom = NULL,
  geom_default = ggplot2::GeomPoint, 
  mapping = NULL,
  data = NULL,
  position = "identity",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE, 
  ...) {

  if(!is.null(compute_panel)){
StatTemp <- ggproto(
  `_class` = "StatTemp",
  `_inherit` = ggplot2::Stat,
  compute_panel = compute_panel,
  required_aes = required_aes)
  }
  
  if(!is.null(compute_group)){
StatTemp <- ggproto(
  `_class` = "StatTemp",
  `_inherit` = ggplot2::Stat,
  compute_group = compute_group,
  required_aes = required_aes)
  }  
  
  if(is.null(geom)){geom <- geom_default}

  ggplot2::layer(
    stat = StatTemp,  # proto object from Step 2
    geom = geom,  # inherit other behavior
    data = data,
    mapping = mapping,
    position = position,
    show.legend = show.legend,
    inherit.aes = inherit.aes,
    params = list(na.rm = na.rm, ...)
  )
}
```

### Try it out

#### abbreviated definition `geom_circle()` using `define_layer_temp`

```{r}
compute_panel_circle <- function(data, scales, n = 15){
  
  data |> 
    mutate(group = row_number()) |> 
    crossing(tibble(z = 0:n)) |>
    mutate(around = 2*pi*z/max(z)) |> 
    mutate(x = x0 + cos(around)*r,
           y = y0 + sin(around)*r) 
  
}

geom_circle <- function(...){
  
  define_layer_temp(
    required_aes = c("x0", "y0", "r"),
    compute_panel = compute_panel_circle,
    geom_default = ggplot2::GeomPath,
    ...)
  
}
```



#### use `geom_circle()`

We see that the layers that are created can always have there geom switched (provided that required aes are computed in the background).

```{r}
library(ggplot2)
data.frame(x0 = 0:1, y0 = 0:1, r = 1:2/3) |>
  ggplot() +
  aes(x0 = x0, y0 = y0, r = r) +
  geom_circle() +
  aes(fill = r)

last_plot() + 
  geom_circle(geom = "point")

```

### Can you define a second w/ the same StatTemp...

#### define geom_heart

```{r}
compute_panel_heart <- function(data, scales){

  data %>%
  mutate(group = row_number()) %>%
  tidyr::crossing(around = 0:15/15) %>%
    dplyr::mutate(
      y = y0 + r * (
        .85 * cos(2*pi*around)
        - .35 * cos(2 * 2*pi*around)
        - .25 * cos(3 * 2*pi*around)
        - .05 * cos(4 * 2*pi*around)
      ),
      x = x0 + r * (sin(2*pi*around)^3))

}

geom_heart <- function(...){

    define_layer_temp(
      required_aes = c("x0", "y0", "r"),
      compute_panel = compute_panel_heart,
      geom_default =ggplot2::GeomPolygon,
      ...)

  }
```

#### try using both geom_heart and geom_circle together...

```{r}
data.frame(x0 = 0:1, y0 = 0:1, r = 1:2/3) |>
  ggplot() +
  aes(x0 = x0, y0 = y0, r = r) +
  geom_heart(alpha = .3) +
  geom_circle(color = "red", 
              data = data.frame(x0 = 4,y0 = 2, r = 1)) + 
  annotate(geom = "point", x = .5, y = .5, size = 8, color = "green")
```






## And `create_layer_temp` method, even more experimental (but feeling nicer to use)

### First just checking out how assign works.

```{r }
assign(x = "geom_circle", 
       value = 
  
  function(...){
  
  define_layer_temp(
    required_aes = c("x0", "y0", "r"),
    compute_panel = compute_panel_circle,
    geom_default =ggplot2::GeomPath,
    ...)
  
}
)
```

### wrapping this...

```{r create_layer_temp}
create_layer_temp <- function(fun_name ="geom_circle", 
                                    compute_panel = NULL,
                                    compute_group = NULL,
                                    required_aes = c("x0", "y0", "r"),
                                    geom_default ="point", ...){

  assign(x = fun_name, 
         value = function(...){
           
  define_layer_temp(
    required_aes = required_aes,
    compute_panel = compute_panel,
    compute_group = compute_group,
    geom_default = geom_default,
    ...)  },
  pos = 1
  )
  
}
```

#### and trying it out

```{r}
create_layer_temp(fun_name = "stat_circle",
                  required_aes = c("x0", "y0", "r"),
                  compute_panel = compute_panel_circle,
                  geom_default ="polygon")


library(ggplot2)
ggplot(cars) + 
  aes(x0 = speed, y0 =  dist, r = 3) + 
  stat_circle(alpha = .4) + 
  coord_equal()
```

## Let's do star example!

```{r}
compute_panel_star <- function(data, scales, n_points = 5, prop_inner_r){

  n_vertices <- n_points * 2
  
  data %>%
  mutate(group = row_number()) %>%
  tidyr::crossing(around = 2*pi*0:(n_vertices)/(n_vertices)+pi/2) %>%
    dplyr::mutate(
      y = y + (r - r*c(rep(c(0,.35), 5), 0)
                ) * sin(around) ,
      x = x + (r - r*c(rep(c(0,.35), 5), 0)
                ) * cos(around)
      ) 

}

create_layer_temp(fun_name = "geom_star", 
                  compute_panel = compute_panel_star,
                  required_aes = c("x", "y", "r"),
                  geom_default ="polygon")


library(ggplot2)
ggplot(cars[1:8,] ) + 
  aes(x = speed, y =  dist, r = 1) + 
  geom_star() + 
  coord_equal()

last_plot() + 
  geom_star(geom = "point", color = "magenta")
```

### a real-world example... :-)

```{r, fig.width=12, fig.height=7}
twinkle_little_star_drm <- "ddsslls ffmmrrd"
twinkle_lyrics <- "Twin-kle twin-kle lit-tle star
How I won-der what you are"


twinkle_little_star_drm |>
ggdoremi:::join_phrases_drm_lyrics(twinkle_lyrics) |>
 ggplot() + 
   aes(y = drm, x = id_in_phrase, r = .58, label = lyric) + 
   facet_wrap(~id_phrase) + 
  geom_star(alpha = .4) +
  geom_text(size = 5) +
  coord_equal() + 
  aes(fill = doremi, color = doremi)

last_plot()$data |> head()
```


# geom_xmean on the fly with compute group...

```{r}
# 1. write some compute
compute_group_xmean <- function(data, scales){
  
  data |> 
    summarize(x = mean(x)) |>
    mutate(xend = x) |>
    mutate(y = -Inf, yend = Inf)

}

# 2. define function
create_layer_temp(fun_name = "geom_xmean",
                  compute_group = compute_group_xmean,
                  required_aes = "x",
                  geom_default ="segment")

# 3. use function
ggplot(cars) + 
  aes(x = speed, y = dist) + 
  geom_point() + 
  geom_xmean() + 
  aes(color = speed > 18)
```

## compute_oval_minmax

```{r}
compute_oval_minmax <- function(data, scales, n = 100){
  
  data |> 
    summarize(
        x0 = sum(range(x))/2,
        y0 = sum(range(y))/2,
        rx = (range(x)[2] - range(x)[1])/2 ,
        ry = (range(y)[2] - range(y)[1])/2) |>
    # mutate(group = row_number()) |> 
    crossing(tibble(z = 0:n)) |>
    mutate(around = 2*pi*z/max(z)) |> 
    mutate(x = x0 + cos(around)*rx,
           y = y0 + sin(around)*ry) 
  
}

mtcars |>
  select(x = wt, y = mpg) |>
  compute_oval_minmax()

# 2. define function
create_layer_temp(fun_name = "geom_oval_xy_range",
                  compute_group = compute_oval_minmax,
                  required_aes = c("x","y"),
                  geom_default = "path")


ggplot(mtcars) + 
  aes(x = wt, y = mpg) +
  geom_point() +
  geom_oval_xy_range()

last_plot() + 
   aes(color = wt > 3.4)
```


# spatial 'status quo' of ggplot2 extension cookbook

```{r}
northcarolina_county_reference0 <-
  sf::st_read(system.file("shape/nc.shp", package="sf")) |>
  dplyr::rename(county_name = NAME,
                fips = FIPS) |>
  dplyr::select(county_name, fips, geometry)

return_st_bbox_df <- function(sf_df){
  
  bb <- sf::st_bbox(sf_df)

  data.frame(xmin = bb[1], ymin = bb[2],
             xmax = bb[3], ymax = bb[4])

}

northcarolina_county_reference<- northcarolina_county_reference0 |>
  dplyr::mutate(bb =
                  purrr::map(geometry,
                             return_st_bbox_df)) |>
  tidyr::unnest(bb) |>
  data.frame()

compute_panel_county <- function(data, scales){
  
  data |> 
    dplyr::inner_join(northcarolina_county_reference)
  
}

StatNcfips <- ggplot2::ggproto(`_class` = "StatNcfips",
                                `_inherit` = ggplot2::Stat,
                                required_aes = "fips|county_name",
                                compute_panel = compute_panel_county)


geom_county <- function(
      mapping = NULL,
      data = NULL,
      position = "identity",
      na.rm = FALSE,
      show.legend = NA,
      inherit.aes = TRUE,
      crs = "NAD27", # "NAD27", 5070, "WGS84", "NAD83", 4326 , 3857
      ...) {

  c(ggplot2::layer_sf(
              stat = StatNcfips,  # proto object from step 2
              geom = ggplot2::GeomSf,  # inherit other behavior
              data = data,
              mapping = mapping,
              position = position,
              show.legend = show.legend,
              inherit.aes = inherit.aes,
              params = rlang::list2(na.rm = na.rm, ...)
              ),
              
              coord_sf(crs = crs,
                       default_crs = sf::st_crs(crs),
                       datum = crs,
                       default = TRUE)
     )
  }




ggnorthcarolina::northcarolina_county_flat |> 
  ggplot() + 
  aes(fips = fips) + 
  geom_county(crs = "NAD83")  + 
  aes(fill = SID74/BIR74)


```

# define_layer_sf_temp build

```{r}
northcarolina_county_reference0 <-
  sf::st_read(system.file("shape/nc.shp", package="sf")) |>
  dplyr::rename(county_name = NAME,
                fips = FIPS) |>
  dplyr::select(county_name, fips, geometry)

return_st_bbox_df <- function(sf_df){
  
  bb <- sf::st_bbox(sf_df)

  data.frame(xmin = bb[1], ymin = bb[2],
             xmax = bb[3], ymax = bb[4])

}


define_layer_sf_temp <- function(ref_df,
                                 geom = NULL, 
                                 geom_default = ggplot2::GeomSf, 
                                 required_aes, 
                                 compute_panel = NULL, 
                                 mapping = NULL,
                                 data = NULL,
                                 position = "identity",
                                 na.rm = FALSE,
                                 show.legend = NA,
                                 inherit.aes = TRUE, 
                                 crs = "NAD27",
                                 ...){


ref_df_w_bb <- 
  ref_df |>
  dplyr::mutate(bb =
                  purrr::map(geometry,
                             return_st_bbox_df)) |>
  tidyr::unnest(bb) |>
  data.frame()

compute_panel_county <- function(data, scales){
  
  data |> 
    dplyr::inner_join(ref_df_w_bb)
  
}

StatTempsf <- ggplot2::ggproto(`_class` = "StatTempsf",
                                `_inherit` = ggplot2::Stat,
                                required_aes = required_aes,
                                compute_panel = NULL)


c(ggplot2::layer_sf(
              stat = StatNcfips,  # proto object from step 2
              geom = ggplot2::GeomSf,  # inherit other behavior
              data = data,
              mapping = mapping,
              position = position,
              show.legend = show.legend,
              inherit.aes = inherit.aes,
              params = rlang::list2(na.rm = na.rm, ...)
              ),
              
              coord_sf(crs = crs,
                       default_crs = sf::st_crs(crs),
                       datum = crs,
                       default = TRUE)
     )
  }



geom_county <- function(...){
  
  sf::st_read(system.file("shape/nc.shp", package="sf")) |>
  dplyr::rename(county_name = NAME,
                fips = FIPS) |>
  dplyr::select(county_name, fips, geometry) |>
  define_layer_sf_temp(required_aes = "fips|county_name",
                       ...)
  
}




ggnorthcarolina::northcarolina_county_flat |> 
  ggplot() + 
  aes(fips = fips) + 
  geom_county()  + 
  aes(fill = SID74/BIR74)


```



```{r}
create_layer_sf_temp <- function(ref_df, 
                                 fun_name ="geom_geo", 
                                 required_aes,
                                 geom = "sf"){

  assign(x = fun_name, 
         value = function(...){
           
  
  define_layer_sf_temp(ref_df = ref_df,
    required_aes = required_aes,
    compute_panel = compute_panel,
    geom = geom,
    ...)  },
  pos = 1
  )
  
}



sf::st_read(system.file("shape/nc.shp", package="sf")) |>
  dplyr::rename(county_name = NAME,
                fips = FIPS) |>
  dplyr::select(county_name, fips, geometry) |>
  create_layer_sf_temp(fun_name = "geom_county",
                       required_aes = "county_name|fips")


ggnorthcarolina::northcarolina_county_flat |> 
  ggplot() + 
  aes(fips = fips) + 
  geom_county()  + 
  aes(fill = SID74/BIR74)

```


# Part II. Packaging and documentation  ðŸš§ âœ… 

## Phase 1. Minimal working package

### Bit A. Created files for package archetecture, running `devtools::create(".")` in interactive session. ðŸš§ âœ…


```{r, eval = F}
devtools::create(".")
```

### Bit B. Added roxygen skeleton? ðŸš§ âœ…

Use a roxygen skeleton for auto documentation and making sure proposed functions are *exported*.  Generally, early on, I don't do much (anything) in terms of filling in the skeleton for documentation, because things may change.

### Bit C. Managed dependencies ? ðŸš§ âœ…

Package dependencies managed, i.e. `depend::function()` in proposed functions and declared in the DESCRIPTION

```{r, eval = F}
usethis::use_package("ggplot2")
```


### Bit D. Moved functions R folder? ðŸš§ âœ…

Use new {readme2pkg} function to do this from readme...

```{r}
readme2pkg::chunk_to_r("define_layer_temp")
readme2pkg::chunk_to_r("create_layer_temp")
```




### Bit E. Run `devtools::check()` and addressed errors. ðŸš§ âœ…

```{r, results='hide', error=T, eval = F}
devtools::check(pkg = ".")
```

### Bit F. Build package ðŸš§ âœ…

```{r, eval = F}
devtools::build()
```


### Bit G. Write and test traditional README that uses built package. ðŸš§ âœ… 

The goal of the {ggtemp} package is to ...

Install package with:

```
remotes::installgithub("EvaMaeRey/readme2pkg.template")
```

Then...

```{r, eval = T}
library(ggtemp)  ##<< change to your package name here

compute_panel_circle <- function(data, scales, n = 15){
  
  data |> 
    mutate(group = row_number()) |> 
    crossing(tibble(z = 0:n)) |>
    mutate(around = 2*pi*z/max(z)) |> 
    mutate(x = x0 + cos(around)*r,
           y = y0 + sin(around)*r) 
  
}

geom_circle_points <- function(...){
  
  ggtemp:::define_layer_temp(
    required_aes = c("x0", "y0", "r"),
    compute_panel = compute_panel_circle,
    geom_default =ggplot2::GeomPoint,
    ...)
  
}


library(ggplot2)
ggplot(cars) +
  aes(x0 = speed, y0 = dist, r = 1) + 
  geom_circle_points()



```

### Bit H. Chosen a license? ðŸš§ âœ…


```{r}
usethis::use_mit_license()
```

### Bit I. Add lifecycle badge (experimental)

```{r}
usethis::use_lifecycle_badge("experimental")
```


## Phase 2: Listen & iterate ðŸš§ âœ…

Try to get feedback from experts on API, implementation, default decisions.  Is there already work that solves this problem? 


## Phase 3: Let things settle

### Bit A. Settle on examples.  Put them in the roxygen skeleton and readme. ðŸš§ âœ…

### Bit B. Written formal tests of functions and save to test that folders ðŸš§ âœ…


That would look like this...

```{r test_calc_times_two_works, eval = F}
library(testthat)

test_that("calc times 2 works", {
  expect_equal(times_two(4), 8)
  expect_equal(times_two(5), 10)
  
})
```


```{r, eval = F}
readme2pkg::chunk_to_tests_testthat("test_calc_times_two_works")
```


### Bit C. Added a description and author information in the DESCRIPTION file ðŸš§ âœ…

### Bit D. Addressed *all* notes, warnings and errors. ðŸš§ âœ…

## Phase 4. Promote to wider audience...

### Bit A. Package website built? ðŸš§ âœ…

### Bit B. Package website deployed? ðŸš§ âœ…

## Phase 5: Harden/commit

### Submit to CRAN? ðŸš§ âœ…

# Appendix: Reports, Environment

## Description file extract

```{r}
# readlines(Description)
```

## Environment

Here I just want to print the packages and the versions

```{r}
all <- sessionInfo() |> print() |> capture.output()
all[11:17]
```

## `devtools::check()` report

```{r, error = T, results="hide", warning=F}
devtools::check(pkg = ".")
```



## Non-developer introduction to package (and test of installed package)

The goal of the {xxx} package 

To install the dev version use the following:

```
remotes::install_github("owner/repo") # 
```  

## Example using package

```{r, eval = F}
library(mypackage)
myfunction(mtcars)
```


