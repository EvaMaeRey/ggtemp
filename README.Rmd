---
output: 
  github_document:
    toc: TRUE

---


```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  eval = T
)
```


Proposing the {ggtemp} package! ðŸ¦„ 
<!-- (typical package introduction write up; but actually aspirational) -->

The goal of {ggtemp} is to make writing some quick useful extension functions succinct. Right now, the amount of code required to write extensions is a bit of a mouthful, and could feel prohibitive for day-to-day analysis.  Specifically, defining new geom_* and stat_* layers outside of the context of a package, I believe, is not common, but could be quite useful, ultimately making plot builds intiuitive, fun, and readable. However the usual amount of code required to make define new geom_* or stat_* functions, might feel like it 'gunks up' your script.

With the {ggtemp} package, we'll live in a different world (ðŸ¦„ ðŸ¦„ ðŸ¦„) where the task is a snap ðŸ«°, and the readability of the in-script definition of a geom_* or stat_* function is quite succinct: 

Proposed API where we create a new geom_* layer function

```
library(ggtemp)

# 1. work out some compute
compute_group_xmean <- function(data, scales){
  
  data |> # a dataframe with vars x, the required aesthetic
    summarize(x = mean(x)) |>
    mutate(xend = x) |>
    mutate(y = -Inf, yend = Inf)

}

# 2. create layer function based on compute geom_xmean)
create_layer_temp(fun_name = "geom_xmean",
                  compute_group = compute_group_xmean,
                  required_aes = "x",
                  geom = "segment")
                  
                  
# 3. Use temp layer!                   
ggplot(data = cars) + 
  aes(x = speed, y = dist) + 
  geom_point() + 
  geom_xmean()
```



# Part I. Work out functionality  âœ… 


## Intro Thoughts

What if you just want to define a basic computational engine (geom_* or stat_* function) on the fly in a script.  It seems like it requires a good amount of code, but there are things that repeat.  Below, we see if we define a StatTemp within a function, and use that function to remove some of the repetition for vanilla-y extensions.

TLDR:  This seems to work, and surprisingly well (??).  I thought I'd only be able to use StatTemp once, but you seem to be able to define multiple geoms_* functions with the same define_temp_geom wrapper...

## Status Quo:  1. compute, 2. ggproto, 3. define layer

```{r cars}
library(tidyverse)
compute_panel_equilateral <- function(data, scales, n = 15){
  
  data |> 
    mutate(group = row_number()) |> 
    crossing(tibble(z = 0:n)) |>
    mutate(around = 2*pi*z/max(z)) |> 
    mutate(x = x0 + cos(around)*r,
           y = y0 + sin(around)*r) 
  
}

StatCircle <- ggproto(
  `_class` = "StatCircle",
  `_inherit` = ggplot2::Stat,
  compute_panel = compute_panel_equilateral,
  required_aes = c("x0", "y0", "r"))

geom_circle <- function(
  mapping = NULL,
  data = NULL,
  position = "identity",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE, ...) {
  ggplot2::layer(
    stat = StatCircle,  # proto object from Step 2
    geom = ggplot2::GeomPolygon,  # inherit other behavior
    data = data,
    mapping = mapping,
    position = position,
    show.legend = show.legend,
    inherit.aes = inherit.aes,
    params = list(na.rm = na.rm, ...)
  )
}

data.frame(x0 = 0:1, y0 = 0:1, r = 1:2/3) |> 
  ggplot() + 
  aes(x0 = x0, y0 = y0, r = r) + 
  geom_circle() + 
  aes(fill = r)
```

## Experimental:  `define_layer_temp()` combines 2 and 3 in using a temp stat


```{r define_layer_temp}
define_layer_temp <- function(
  required_aes,
  compute_panel = NULL, 
  compute_group = NULL,
  geom = ggplot2::GeomPoint, 
  mapping = NULL,
  data = NULL,
  position = "identity",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE, 
  ...) {

  if(!is.null(compute_panel)){
StatTemp <- ggproto(
  `_class` = "StatTemp",
  `_inherit` = ggplot2::Stat,
  compute_panel = compute_panel,
  required_aes = required_aes)
  }
  
  if(!is.null(compute_group)){
StatTemp <- ggproto(
  `_class` = "StatTemp",
  `_inherit` = ggplot2::Stat,
  compute_group = compute_group,
  required_aes = required_aes)
  }  

  ggplot2::layer(
    stat = StatTemp,  # proto object from Step 2
    geom = geom,  # inherit other behavior
    data = data,
    mapping = mapping,
    position = position,
    show.legend = show.legend,
    inherit.aes = inherit.aes,
    params = list(na.rm = na.rm, ...)
  )
}
```

### Try it out

#### abbreviated definition `geom_circle()` using `define_layer_temp`

```{r}
compute_panel_circle <- function(data, scales, n = 15){
  
  data |> 
    mutate(group = row_number()) |> 
    crossing(tibble(z = 0:n)) |>
    mutate(around = 2*pi*z/max(z)) |> 
    mutate(x = x0 + cos(around)*r,
           y = y0 + sin(around)*r) 
  
}

geom_circle <- function(...){
  
  define_layer_temp(
    required_aes = c("x0", "y0", "r"),
    compute_panel = compute_panel_circle,
    geom = ggplot2::GeomPath,
    ...)
  
}
```



#### use `geom_circle()`

```{r}
library(ggplot2)
data.frame(x0 = 0:1, y0 = 0:1, r = 1:2/3) |>
  ggplot() +
  aes(x0 = x0, y0 = y0, r = r) +
  geom_circle() +
  aes(fill = r)
```

### Can you define a second w/ the same StatTemp...

#### define geom_heart

```{r}
compute_panel_heart <- function(data, scales){

  data %>%
  mutate(group = row_number()) %>%
  tidyr::crossing(around = 0:15/15) %>%
    dplyr::mutate(
      y = y0 + r * (
        .85 * cos(2*pi*around)
        - .35 * cos(2 * 2*pi*around)
        - .25 * cos(3 * 2*pi*around)
        - .05 * cos(4 * 2*pi*around)
      ),
      x = x0 + r * (sin(2*pi*around)^3))

}

geom_heart <- function(...){

    define_layer_temp(
      required_aes = c("x0", "y0", "r"),
      compute_panel = compute_panel_heart,
      geom = ggplot2::GeomPolygon,
      ...)

  }
```

#### try using both geom_heart and geom_circle together...

```{r}
data.frame(x0 = 0:1, y0 = 0:1, r = 1:2/3) |>
  ggplot() +
  aes(x0 = x0, y0 = y0, r = r) +
  geom_heart(alpha = .3) +
  geom_circle(color = "red", 
              data = data.frame(x0 = 4,y0 = 2, r = 1)) + 
  annotate(geom = "point", x = .5, y = .5, size = 8, color = "green")
```






## And `create_layer_temp` method, even more experimental (but feeling nicer to use)

### First just checking out how assign works.

```{r }
assign(x = "geom_circle", 
       value = 
  
  function(...){
  
  define_layer_temp(
    required_aes = c("x0", "y0", "r"),
    compute_panel = compute_panel_circle,
    geom = ggplot2::GeomPath,
    ...)
  
}
)
```

### wrapping this...

```{r create_layer_temp}
create_layer_temp <- function(fun_name ="geom_circle", 
                                    compute_panel = NULL,
                                    compute_group = NULL,
                                    required_aes = c("x0", "y0", "r"),
                                    geom = "point"){

  assign(x = fun_name, 
         value = function(...){
           
  define_layer_temp(
    required_aes = required_aes,
    compute_panel = compute_panel,
    compute_group = compute_group,
    geom = geom,
    ...)  },
  pos = 1
  )
  
}
```

#### and trying it out

```{r}
create_layer_temp(fun_name = "stat_circle",
                  required_aes = c("x0", "y0", "r"),
                  compute_panel = compute_panel_circle,
                  geom = "polygon")


library(ggplot2)
ggplot(cars) + 
  aes(x0 = speed, y0 =  dist, r = 3) + 
  stat_circle(alpha = .4) + 
  coord_equal()
```

## Let's do star example!

```{r}
compute_panel_star <- function(data, scales, n_points = 5, prop_inner_r){

  n_vertices <- n_points * 2
  
  data %>%
  mutate(group = row_number()) %>%
  tidyr::crossing(around = 2*pi*0:(n_vertices)/(n_vertices)+pi/2) %>%
    dplyr::mutate(
      y = y + (r - r*c(rep(c(0,.35), 5), 0)
                ) * sin(around) ,
      x = x + (r - r*c(rep(c(0,.35), 5), 0)
                ) * cos(around)
      ) 

}

create_layer_temp(fun_name = "geom_star", 
                  compute_panel = compute_panel_star,
                  required_aes = c("x", "y", "r"),
                  geom = "polygon")


library(ggplot2)
ggplot(cars[1:8,] ) + 
  aes(x = speed, y =  dist, r = 1) + 
  geom_star() + 
  coord_equal()
```

### a real-world example... :-)

```{r, fig.width=12, fig.height=7}
twinkle_little_star_drm <- "ddsslls ffmmrrd"
twinkle_lyrics <- "Twin-kle twin-kle lit-tle star
How I won-der what you are"


twinkle_little_star_drm |>
ggdoremi:::join_phrases_drm_lyrics(twinkle_lyrics) |>
 ggplot() + 
   aes(y = drm, x = id_in_phrase, r = .58, label = lyric) + 
   facet_wrap(~id_phrase) + 
  geom_star(alpha = .4) +
  geom_text(size = 5) +
  coord_equal() + 
  aes(fill = doremi, color = doremi)
```


# geom_xmean on the fly with compute group...

```{r}
compute_group_xmean <- function(data, scales){
  
  data |> # a dataframe with vars x, the required aesthetic
    summarize(x = mean(x)) |>
    mutate(xend = x) |>
    mutate(y = -Inf, yend = Inf)

}

create_layer_temp(fun_name = "geom_xmean",
                  compute_group = compute_group_xmean,
                  required_aes = "x",
                  geom = "segment")

ggplot(cars) + 
  aes(x = speed, x0 = speed, y0 =  dist, r = 1) + 
  stat_circle() + 
  geom_xmean() + 
  aes(color = speed > 18)

```





# Part II. Packaging and documentation  ðŸš§ âœ… 

## Phase 1. Minimal working package

### Bit A. Created files for package archetecture, running `devtools::create(".")` in interactive session. ðŸš§ âœ…


```{r, eval = F}
devtools::create(".")
```

### Bit B. Added roxygen skeleton? ðŸš§ âœ…

Use a roxygen skeleton for auto documentation and making sure proposed functions are *exported*.  Generally, early on, I don't do much (anything) in terms of filling in the skeleton for documentation, because things may change.

### Bit C. Managed dependencies ? ðŸš§ âœ…

Package dependencies managed, i.e. `depend::function()` in proposed functions and declared in the DESCRIPTION

```{r, eval = F}
usethis::use_package("ggplot2")
```


### Bit D. Moved functions R folder? ðŸš§ âœ…

Use new {readme2pkg} function to do this from readme...

```{r}
readme2pkg::chunk_to_r("define_layer_temp")
readme2pkg::chunk_to_r("create_layer_temp")
```




### Bit E. Run `devtools::check()` and addressed errors. ðŸš§ âœ…

```{r, results='hide', error=T, eval = F}
devtools::check(pkg = ".")
```

### Bit F. Build package ðŸš§ âœ…

```{r, eval = F}
devtools::build()
```


### Bit G. Write and test traditional README that uses built package. ðŸš§ âœ… 

The goal of the {ggtemp} package is to ...

Install package with:

```
remotes::installgithub("EvaMaeRey/readme2pkg.template")
```

Then...

```{r, eval = T}
library(ggtemp)  ##<< change to your package name here

compute_panel_circle <- function(data, scales, n = 15){
  
  data |> 
    mutate(group = row_number()) |> 
    crossing(tibble(z = 0:n)) |>
    mutate(around = 2*pi*z/max(z)) |> 
    mutate(x = x0 + cos(around)*r,
           y = y0 + sin(around)*r) 
  
}

geom_circle_points <- function(...){
  
  ggtemp:::define_layer_temp(
    required_aes = c("x0", "y0", "r"),
    compute_panel = compute_panel_circle,
    geom = ggplot2::GeomPoint,
    ...)
  
}


library(ggplot2)
ggplot(cars) +
  aes(x0 = speed, y0 = dist, r = 1) + 
  geom_circle_points()



```

### Bit H. Chosen a license? ðŸš§ âœ…


```{r}
usethis::use_mit_license()
```

### Bit I. Add lifecycle badge (experimental)

```{r}
usethis::use_lifecycle_badge("experimental")
```


## Phase 2: Listen & iterate ðŸš§ âœ…

Try to get feedback from experts on API, implementation, default decisions.  Is there already work that solves this problem? 


## Phase 3: Let things settle

### Bit A. Settle on examples.  Put them in the roxygen skeleton and readme. ðŸš§ âœ…

### Bit B. Written formal tests of functions and save to test that folders ðŸš§ âœ…


That would look like this...

```{r test_calc_times_two_works, eval = F}
library(testthat)

test_that("calc times 2 works", {
  expect_equal(times_two(4), 8)
  expect_equal(times_two(5), 10)
  
})
```


```{r, eval = F}
readme2pkg::chunk_to_tests_testthat("test_calc_times_two_works")
```


### Bit C. Added a description and author information in the DESCRIPTION file ðŸš§ âœ…

### Bit D. Addressed *all* notes, warnings and errors. ðŸš§ âœ…

## Phase 4. Promote to wider audience...

### Bit A. Package website built? ðŸš§ âœ…

### Bit B. Package website deployed? ðŸš§ âœ…

## Phase 5: Harden/commit

### Submit to CRAN? ðŸš§ âœ…

# Appendix: Reports, Environment

## Description file extract

```{r}
# readlines(Description)
```

## Environment

Here I just want to print the packages and the versions

```{r}
all <- sessionInfo() |> print() |> capture.output()
all[11:17]
```

## `devtools::check()` report

```{r, error = T, results="hide", warning=F}
devtools::check(pkg = ".")
```



## Non-developer introduction to package (and test of installed package)

The goal of the {xxx} package 

To install the dev version use the following:

```
remotes::install_github("owner/repo") # 
```  

## Example using package

```{r, eval = F}
library(mypackage)
myfunction(mtcars)
```


